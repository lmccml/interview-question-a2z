#1.如何创建线程？如何保证线程安全？

#2.如何实现一个线程安全的数据结构

#3.如何避免死锁

#4.Volatile关键字的作用？

#5.HashMap在多线程环境下使用需要注意什么？为什么？

#6.Java程序中启动一个线程是用run还是start？

#7.什么是守护线程？有什么用？

#8.什么是死锁？如何避免

#9.线程和进程的差别是什么？

#10.Java里面的Threadlocal是怎样实现的？

#11.ConcurrentHashMap的实现原理是？

#12.sleep和wait区别

#13.notify和notifyAll区别

#14.volatile关键字的作

#15.ThreadLocal的作用与实现

#16.两个线程如何串行执行

#17.上下文切换是什么含义

#18.可以运行时kill掉一个线程吗？

#19.什么是条件锁、读写锁、自旋锁、可重入锁？

#20.线程池ThreadPoolExecutor的实现原理？

#22.线程中为何stop()和suspend()方法不推荐使用
线程中stop（）方法作为一种粗暴的线程终止行为，在线程终止之前没有对其做任何的清除操作，因此具有固有的不安全性。 
用Thread.stop()方法来终止线程将会释放该线程对象已经锁定的所有监视器。
如果以前受这些监视器保护的任何对象都处于不连贯状态，那么损坏的对象对其他线程可见，这有可能导致不安全的操作。 
由于上述原因，因此不应该使用stop()方法，而应该在自己的Thread类中置入一个标志，用于控制目标线程是活动还是停止。
如果该标志指示它要停止运行，可使其结束run（）方法。如果目标线程等待很长时间，则应使用interrupt()方法来中断该等待。
suspend()方法 该方法已经遭到反对，因为它具有固有的死锁倾向。调用suspend（）方法的时候，目标线程会停下来。
如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前，其他线程都不能访问该资源。
除非被挂起的线程恢复运行。对任何其他线程来说，如果想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。
由于上述原因，因此不应该使用suspend（）方法，而应在自己的thread类中置入一个标志，用于控制线程是活动还是挂起。
如果标志指出线程应该挂起，那么用wait（）方法命令其进入等待状态。如果标志指出线程应当恢复，那么用notify()方法重新启动线程。

#23.线程如何退出结束
设置开关状态和中断

#24.java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别

#25.ThreadLocal的原理和使用场景

#26.为什么线程执行要调用start而不是直接run
直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行

#27.为什么使用 Executor 框架？

#28.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？

